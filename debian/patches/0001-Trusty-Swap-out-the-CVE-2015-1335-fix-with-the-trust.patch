From 3e3c933900c23edf4e378127b6520c91e9f87546 Mon Sep 17 00:00:00 2001
From: Serge Hallyn <serge.hallyn@ubuntu.com>
Date: Wed, 28 Oct 2015 13:51:07 -0500
Subject: Trusty: Swap out the CVE-2015-1335 fix with the
 trusty-kernel-friendly one

The upstream fix for CVE-2015-1335 exposes bugs in trusty's kernel's
overlayfs+apparmor behavior, breaking lxc-test-unpriv.  In trusty we
use a separate lxc patch for CVE-2015-1335 for this reason.

This patch against upstream stable-1.0 replaces the upstream fix with
the trusty-compatible one.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
---
 src/lxc/utils.c            | 286 +++++++++++++++------------------------------
 src/tests/lxc-test-symlink |   4 +
 2 files changed, 100 insertions(+), 190 deletions(-)

diff --git a/src/lxc/utils.c b/src/lxc/utils.c
index 214c5a8..fb45e1f 100644
--- a/src/lxc/utils.c
+++ b/src/lxc/utils.c
@@ -1155,234 +1155,140 @@ err:
 }
 
 /*
- * @path:    a pathname where / replaced with '\0'.
- * @offsetp: pointer to int showing which path segment was last seen.
- *           Updated on return to reflect the next segment.
- * @fulllen: full original path length.
- * Returns a pointer to the next path segment, or NULL if done.
+ * ws points into an array of \0-separate path elements.
+ * ws should be pointing to one of the path elements or
+ * the next \0.  It will return the first character of the
+ * next path element.
  */
-static char *get_nextpath(char *path, int *offsetp, int fulllen)
-{
-	int offset = *offsetp;
-
-	if (offset >= fulllen)
-		return NULL;
-
-	while (path[offset] != '\0' && offset < fulllen)
-		offset++;
-	while (path[offset] == '\0' && offset < fulllen)
-		offset++;
-
-	*offsetp = offset;
-	return (offset < fulllen) ? &path[offset] : NULL;
+static char *next_word(char *ws) {
+	while (*ws && *ws != ' ') ws++;
+	while (*ws && *ws == ' ') ws++;
+	return ws;
 }
 
 /*
- * Check that @subdir is a subdir of @dir.  @len is the length of
- * @dir (to avoid having to recalculate it).
+ * copy src to dest, collapsing multiple '/' into one and
+ * collapsing '/./' to '/'
  */
-static bool is_subdir(const char *subdir, const char *dir, size_t len)
+static void copy_cleanedup(char *dest, const char *src)
 {
-	size_t subdirlen = strlen(subdir);
-
-	if (subdirlen < len)
-		return false;
-	if (strncmp(subdir, dir, len) != 0)
-		return false;
-	if (dir[len-1] == '/')
-		return true;
-	if (subdir[len] == '/' || subdirlen == len)
-		return true;
-	return false;
+	char *orig = dest;
+	while (*src) {
+		if (*src == '/' && *(src+1) == '/') {
+			src++;
+			continue;
+		}
+		if (*src == '/' && *(src+1) == '.' &&
+			(*(src+2) == '/' || *(src+2) == '\0')) {
+			src += 2;
+			continue;
+		}
+		*(dest++) = *(src++);
+	}
+	*dest = '\0';
+	/* remove trailing / */
+	dest--;
+	while (dest > orig && *dest == '/')
+		*(dest--) = '\0';
 }
 
-/*
- * Check if the open fd is a symlink.  Return -ELOOP if it is.  Return
- * -ENOENT if we couldn't fstat.  Return 0 if the fd is ok.
- */
-static int check_symlink(int fd)
+static size_t count_mountinfo_lines(void)
 {
-	struct stat sb;
-	int ret = fstat(fd, &sb);
-	if (ret < 0)
-		return -ENOENT;
-	if (S_ISLNK(sb.st_mode))
-		return -ELOOP;
-	return 0;
-}
+	FILE *f = fopen("/proc/self/mountinfo", "r");
+	char *line = NULL;
+	size_t len = 0, i = 0;
+	if (!f)
+		return 0;
 
-/*
- * Open a file or directory, provided that it contains no symlinks.
- *
- * CAVEAT: This function must not be used for other purposes than container
- * setup before executing the container's init
- */
-static int open_if_safe(int dirfd, const char *nextpath)
-{
-	int newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);
-	if (newfd >= 0) // was not a symlink, all good
-		return newfd;
-
-	if (errno == ELOOP)
-		return newfd;
-
-	if (errno == EPERM || errno == EACCES) {
-		/* we're not root (cause we got EPERM) so
-		   try opening with O_PATH */
-		newfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);
-		if (newfd >= 0) {
-			/* O_PATH will return an fd for symlinks.  We know
-			 * nextpath wasn't a symlink at last openat, so if fd
-			 * is now a link, then something * fishy is going on
-			 */
-			int ret = check_symlink(newfd);
-			if (ret < 0) {
-				close(newfd);
-				newfd = ret;
-			}
-		}
-	}
+	while (getline(&line, &len, f) != -1)
+		i++;
+	fclose(f);
 
-	return newfd;
+	free(line);
+	return i;
 }
 
 /*
- * Open a path intending for mounting, ensuring that the final path
- * is inside the container's rootfs.
- *
- * CAVEAT: This function must not be used for other purposes than container
- * setup before executing the container's init
- *
- * @target: path to be opened
- * @prefix_skip: a part of @target in which to ignore symbolic links.  This
- * would be the container's rootfs.
- *
- * Return an open fd for the path, or <0 on error.
+ * This is only used during container startup.  So we know we won't race
+ * with anyone else mounting.  Check the last line in /proc/self/mountinfo
+ * to make sure the target is under the container root.
  */
-static int open_without_symlink(const char *target, const char *prefix_skip)
+static bool ensure_not_symlink(const char *target, const char *croot, size_t prevlines)
 {
-	int curlen = 0, dirfd, fulllen, i;
-	char *dup = NULL;
-
-	fulllen = strlen(target);
-
-	/* make sure prefix-skip makes sense */
-	if (prefix_skip) {
-		curlen = strlen(prefix_skip);
-		if (!is_subdir(target, prefix_skip, curlen)) {
-			ERROR("WHOA there - target '%s' didn't start with prefix '%s'",
-				target, prefix_skip);
-			return -EINVAL;
-		}
-		/*
-		 * get_nextpath() expects the curlen argument to be
-		 * on a  (turned into \0) / or before it, so decrement
-		 * curlen to make sure that happens
-		 */
-		if (curlen)
-			curlen--;
-	} else {
-		prefix_skip = "/";
-		curlen = 0;
+	FILE *f = fopen("/proc/self/mountinfo", "r");
+	char *line = NULL, *ws = NULL, *we = NULL, *tgtcopy;
+	size_t len = 0, i = 0;
+	bool ret = false;
+
+	if (!croot || croot[0] == '\0')
+		return true;
+
+	if (!f) {
+		ERROR("Cannot open /proc/self/mountinfo");
+		return false;
 	}
 
-	/* Make a copy of target which we can hack up, and tokenize it */
-	if ((dup = strdup(target)) == NULL) {
-		SYSERROR("Out of memory checking for symbolic link");
-		return -ENOMEM;
+	while (getline(&line, &len, f) != -1 && i < prevlines) {
+		i++;
 	}
-	for (i = 0; i < fulllen; i++) {
-		if (dup[i] == '/')
-			dup[i] = '\0';
+	fclose(f);
+
+	if (!line)
+		return false;
+	ws = line;
+	for (i = 0; i < 4; i++)
+		ws = next_word(ws);
+	if (!*ws)
+		goto out;
+	we = ws;
+	while (*we && *we != ' ')
+		we++;
+	if (!*we)
+		goto out;
+	*we = '\0';
+
+	tgtcopy = alloca(strlen(target) + 1);
+	copy_cleanedup(tgtcopy, target);
+	/* now make sure that ws starts with croot and ends with rest of target */
+	if (croot && strncmp(ws, croot, strlen(croot)) != 0) {
+		ERROR("Mount onto %s resulted in %s, does not match root %s\n",
+			target, ws, croot);
+		goto out;
 	}
 
-	dirfd = open(prefix_skip, O_RDONLY);
-	if (dirfd < 0)
+	size_t start = croot ? strlen(croot) : 0;
+	if (strcmp(ws + start, tgtcopy + start) != 0) {
+		ERROR("Mount onto %s resulted in %s, not %s\n", target, ws, tgtcopy);
 		goto out;
-	while (1) {
-		int newfd, saved_errno;
-		char *nextpath;
-
-		if ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)
-			goto out;
-		newfd = open_if_safe(dirfd, nextpath);
-		saved_errno = errno;
-		close(dirfd);
-		dirfd = newfd;
-		if (newfd < 0) {
-			errno = saved_errno;
-			if (errno == ELOOP)
-				SYSERROR("%s in %s was a symbolic link!", nextpath, target);
-			else
-				SYSERROR("Error examining %s in %s", nextpath, target);
-			goto out;
-		}
 	}
 
+	ret = true;
+
 out:
-	free(dup);
-	return dirfd;
+	free(line);
+	return ret;
 }
-
 /*
  * Safely mount a path into a container, ensuring that the mount target
  * is under the container's @rootfs.  (If @rootfs is NULL, then the container
  * uses the host's /)
- *
- * CAVEAT: This function must not be used for other purposes than container
- * setup before executing the container's init
  */
 int safe_mount(const char *src, const char *dest, const char *fstype,
 		unsigned long flags, const void *data, const char *rootfs)
 {
-	int srcfd = -1, destfd, ret, saved_errno;
-	char srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>
-	const char *mntsrc = src;
-
-	if (!rootfs)
-		rootfs = "";
-
-	/* todo - allow symlinks for relative paths if 'allowsymlinks' option is passed */
-	if (flags & MS_BIND && src && src[0] != '/') {
-		INFO("this is a relative bind mount");
-		srcfd = open_without_symlink(src, NULL);
-		if (srcfd < 0)
-			return srcfd;
-		ret = snprintf(srcbuf, 50, "/proc/self/fd/%d", srcfd);
-		if (ret < 0 || ret > 50) {
-			close(srcfd);
-			ERROR("Out of memory");
-			return -EINVAL;
-		}
-		mntsrc = srcbuf;
-	}
-
-	destfd = open_without_symlink(dest, rootfs);
-	if (destfd < 0) {
-		if (srcfd != -1)
-			close(srcfd);
-		return destfd;
-	}
-
-	ret = snprintf(destbuf, 50, "/proc/self/fd/%d", destfd);
-	if (ret < 0 || ret > 50) {
-		if (srcfd != -1)
-			close(srcfd);
-		close(destfd);
-		ERROR("Out of memory");
-		return -EINVAL;
-	}
+	int ret;
+	size_t nlines = count_mountinfo_lines();
 
-	ret = mount(mntsrc, destbuf, fstype, flags, data);
-	saved_errno = errno;
-	if (srcfd != -1)
-		close(srcfd);
-	close(destfd);
+	ret = mount(src, dest, fstype, flags, data);
 	if (ret < 0) {
-		errno = saved_errno;
-		SYSERROR("Failed to mount %s onto %s", src, dest);
+		SYSERROR("Mount of '%s' onto '%s' failed", src, dest);
 		return ret;
 	}
 
+	if (!ensure_not_symlink(dest, rootfs, nlines)) {
+		ERROR("Mount of '%s' onto '%s' was onto a symlink!", src, dest);
+		umount(dest);
+		return -1;
+	}
 	return 0;
 }
diff --git a/src/tests/lxc-test-symlink b/src/tests/lxc-test-symlink
index 56b7cf6..1e32d66 100644
--- a/src/tests/lxc-test-symlink
+++ b/src/tests/lxc-test-symlink
@@ -51,6 +51,10 @@ lxc.mount.entry = $dirname opt/xxx/dir none bind,create=dir
 lxc.mount.entry = $fname opt/xxx/file none bind,create=file
 lxc.mount.entry = $fname2 opt/xxx/file2 none bind
 lxc.mount.entry = $dirname /var/lib/lxc/symtest1/rootfs/opt/xxx/dir2 none bind,create=dir
+lxc.mount.entry = $dirname /var/lib/lxc/symtest1/rootfs/opt/xxx//././//dir2 none bind,create=dir
+lxc.mount.entry = $dirname /var/lib/lxc/symtest1/rootfs/opt/xxx//././//dir3// none bind,create=dir
+lxc.mount.entry = $dirname /var/lib/lxc/symtest1/rootfs/opt/xxx//././//dir4/. none bind,create=dir
+
 EOF
 
 # Regular - should succeed
