Description: Fix recursive bind mounts
 If a lxc.mount.entry is a recursive bind mount, then more than one new
 line is appended to /proc/self/mountinfo.  But our patch to detect
 symbolic links only checks the last line.  So instead find the number
 of lines before we do the mount, and only verify the next line.
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1509752

Index: lxc-1.0.7/src/lxc/utils.c
===================================================================
--- lxc-1.0.7.orig/src/lxc/utils.c	2015-10-28 16:18:39.000000000 +0000
+++ lxc-1.0.7/src/lxc/utils.c	2015-10-28 17:15:19.329046439 +0000
@@ -1361,16 +1361,32 @@
 		*(dest--) = '\0';
 }
 
+static size_t count_mountinfo_lines(void)
+{
+	FILE *f = fopen("/proc/self/mountinfo", "r");
+	char *line = NULL;
+	size_t len = 0, i = 0;
+	if (!f)
+		return 0;
+
+	while (getline(&line, &len, f) != -1)
+		i++;
+	fclose(f);
+
+	free(line);
+	return i;
+}
+
 /*
  * This is only used during container startup.  So we know we won't race
  * with anyone else mounting.  Check the last line in /proc/self/mountinfo
  * to make sure the target is under the container root.
  */
-static bool ensure_not_symlink(const char *target, const char *croot)
+static bool ensure_not_symlink(const char *target, const char *croot, size_t prevlines)
 {
 	FILE *f = fopen("/proc/self/mountinfo", "r");
 	char *line = NULL, *ws = NULL, *we = NULL, *tgtcopy;
-	size_t len = 0, i;
+	size_t len = 0, i = 0;
 	bool ret = false;
 
 	if (!croot || croot[0] == '\0')
@@ -1381,7 +1397,8 @@
 		return false;
 	}
 
-	while (getline(&line, &len, f) != -1) {
+	while (getline(&line, &len, f) != -1 && i < prevlines) {
+		i++;
 	}
 	fclose(f);
 
@@ -1429,12 +1446,15 @@
 		unsigned long flags, const void *data, const char *rootfs)
 {
 	int ret;
+	size_t nlines = count_mountinfo_lines();
+
 	ret = mount(src, dest, fstype, flags, data);
 	if (ret < 0) {
 		SYSERROR("Mount of '%s' onto '%s' failed", src, dest);
 		return ret;
 	}
-	if (!ensure_not_symlink(dest, rootfs)) {
+
+	if (!ensure_not_symlink(dest, rootfs, nlines)) {
 		ERROR("Mount of '%s' onto '%s' was onto a symlink!", src, dest);
 		umount(dest);
 		return -1;
